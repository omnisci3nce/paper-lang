(* open Codegen

module CodeGen : CodeGenerator = struct
  let new_generator filename = new_generator_ filename ".s"
  let close_generator g = close_out g.channel

  let generate_begin =
    "
    ; Generated by Sibyl-lang compiler
    section .data
      out: db '%d', 10, 0

    section .text
    global _start       ; Provide program starting address to linker
    "
    
    let generate_entrypoint =
    "
    extern printf
    extern addTen

    _start:
      ; Preallocate 1024 bytes on the stack to use for the whole program (for now)
      sub rsp, 1024
    "
    
    let generate_end =
    "
    add rsp, 1024 ; Return stack pointer to start 
    "
    
    let generate_exit = "
    ; Load Linux exit syscall
    mov rdi, 0
    mov rax, 60
    syscall
    "
  let var g s = print_string "str:"; print_string s; Helpers.print_hashtbl g.variables; "[rsp+" ^ string_of_int (Hashtbl.find g.variables s) ^ "]"
  let gen_plus_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rcx, " ^ b)
    |> emit "add rax, rcx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_sub_op _a _b _gen = ("", 0)
  let gen_mult_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rdx, " ^ b)
    |> emit "mul rdx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_and_op _ _ _ = failwith "not yet"
  let gen_or_op _ _ _ = failwith "not yet"
  let gen_not_op _ _ = failwith "not yet"
  let gen_print var_name gen =
    print_string "print"; print_string var_name; 
    let offset = Hashtbl.find gen.variables var_name in
  emit ("
  mov edi, out      ; 64-bit ABI passing order starts w/ edi, esi, ... so format string goes into the first argument
  mov esi, [rsp+" ^ string_of_int offset ^ "]  ; arg1 goes into esi
  mov eax, 0        ; printf has varargs so eax counts num. of non-integer arguments being passed
  call printf
  ") gen
  let gen_copy_ident target name gen = 
    print_string "HELLO"; print_string target; print_string name;
    gen
    |> emit ("mov rax, " ^ var gen name)
    |> emit ("mov " ^ var gen target ^ ", rax")
    let gen_assign target str gen = gen
    |> emit ("mov qword " ^ var gen target ^ ", " ^ str) (* only dealing with 64 bit data types for now *)

  let gen_def_function _ _ _ (g: generator) = g
end *)