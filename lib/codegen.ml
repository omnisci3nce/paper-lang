(* Turn AST into assembly *)

open Lexer
open Parser

let generate_begin =
"
; Generated by Paper-lang compiler
section .data
  out: db '%d', 10, 0

section .text
global _start       ; Provide program starting address to linker
"

let generate_startup =
"
extern printf

_start:
  ; Preallocate 1024 bytes on the stack to use for the whole program (for now)
  sub rsp, 1024

"

let generate_end =
"
  add rsp, 1024 ; Return stack pointer to start 
"

let generate_exit = "
  ; Load Linux exit syscall
  mov rdi, 0
  mov rax, 60
  syscall
"

(* type offset = int *)
type generator = {
  variables: (string, int) Hashtbl.t;
  mutable instruction_count: int;
  mutable asm: string;
  filepath: string;
  channel: out_channel
}

let new_generator filename =
  let filepath = (Filename.chop_extension filename) ^ ".s" in
  {
    variables = Hashtbl.create 100;
    asm = "";
    instruction_count = 0;
    filepath;
    channel = open_out filepath
  }

let close_generator generator = close_out generator.channel

(* emit one line of asm *)
let emit str gen =
  gen.instruction_count <- gen.instruction_count + 1;
  gen.asm <- gen.asm ^ "  " ^ str ^ "\n";
  gen

  

module Instr = struct
  (*  *)
end
  
let bottom_var g = Hashtbl.fold (fun _ v c -> if v >= c then (v+8) else c) g.variables 0
let empty_var g i = (bottom_var g)+(8*(i-1))

let is_alloc_var gen var_name = Hashtbl.mem gen.variables var_name
let alloc_var var_name (g: generator) = if Hashtbl.mem g.variables var_name then
                                          failwith "Var already exists!!!"
                                        else
                                          let available = empty_var g 1 in
                                          Hashtbl.add g.variables var_name available; available
let temp_v_counter = ref 1
let alloc_temp_var g = 
  let var_name = ("__temp" ^ (string_of_int !temp_v_counter))  in
  if Hashtbl.mem g.variables var_name then
    failwith "Var already exists!!!"
  else let available = empty_var g 1 in
    temp_v_counter := !temp_v_counter + 1;
    Hashtbl.add g.variables var_name available; (var_name, available)
      
let gen_plus_op a b gen =
  let name, offset = alloc_temp_var gen in
  print_string "HERE: "; print_string name; print_newline ();
  let _ = gen
  |> emit ("mov rax, " ^  a)
  |> emit ("mov rcx, " ^ b)
  |> emit "add rax, rcx ; output of addition is now in rax"
  |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
  in
  (name, offset)

let gen_print var_name gen = 
  let offset = Hashtbl.find gen.variables var_name in
emit ("
  mov edi, out      ; 64-bit ABI passing order starts w/ edi, esi, ... so format string goes into the first argument
  mov esi, [rsp+" ^ string_of_int offset ^ "]  ; arg1 goes into esi
  mov eax, 0        ; printf has varargs so eax counts num. of non-integer arguments being passed
  call printf
") gen

let var g s = "[rsp+" ^ string_of_int (Hashtbl.find g.variables s) ^ "]"

let rec gen_from_expr gen expr : (generator * string) = match expr with
  | Binary b -> begin
    match b.operator with
    | t when t.token_type = Plus -> begin
      match b.left_expr, b.right_expr with
      (* Num + Num *)
      | Literal (_, NumberLiteral a),  Literal (_, NumberLiteral b) ->
        let (name, _) = gen_plus_op (string_of_int a) (string_of_int b) gen in
        Hashtbl.iter (fun x y -> Printf.printf "%s -> %d\n" x y) gen.variables;
        gen, name
      (* Num + Expr *)
      | Literal (_, NumberLiteral a), e ->
        let (new_gen, temp_name) = gen_from_expr gen e in
        let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
        new_gen, name
      (* Or *)
      (* Expr + Num *)
     
      | _ -> failwith "Cant add these types"
    end
    | _ -> gen, ""
  end
  | _ -> gen, ""

let generate_copy_ident target name gen = 
  gen
  |> emit ("mov rax, " ^ var gen name)
  |> emit ("mov " ^ var gen target ^ ", rax")

let gen_from_stmt gen (ast: statement) = match ast with
  | Expression e ->
    begin
      match e with
      | Let assignment ->
        (* Check if var has already been allocated *)
        let _offset = if is_alloc_var gen assignment.identifier then
          Hashtbl.find gen.variables assignment.identifier
        else 
        (* Allocate the variable to keep track of it *)
          alloc_var assignment.identifier gen
        in
        (* Compute what we want to store in it *)
        Hashtbl.iter (fun x y -> Printf.printf "%s -> %d\n" x y) gen.variables;
        let (new_gen, name) = gen_from_expr gen assignment.expr in
        Hashtbl.iter (fun x y -> Printf.printf "%s -> %d\n" x y) gen.variables;
        (* let _ = generate_copy_ident assignment.identifier name gen in  *)
        (* let _offset2 = Hashtbl.find new_gen.variables name in *)
        let new_gen = generate_copy_ident assignment.identifier name new_gen in
        new_gen
      | _ -> gen
    end
  | Print e -> begin
    match e with
    | Var v -> gen_print v gen
    | _ -> gen
  end

let codegen gen (ast: statement list) : string = 
  let _stmt = List.nth ast 0 in
  let rec inner gen stmts = match stmts with
    | [] -> gen
    | s :: rest ->
      let next = gen_from_stmt gen s in
      inner next rest
  in
  let final = inner gen ast in
  let final = gen_print "a" final in
  let output = generate_begin ^ generate_startup ^  final.asm ^ generate_end ^ generate_exit in
  output

let test_gen () = 
  let s = "let a = 10 + 10 + 10\n" in
  let t = s |> tokenise in List.iter print_token t;
  let gen = new_generator "output.s" in
  print_endline "Parsed:";
  let ast = s |> tokenise |> parse  in List.iter print_stmt ast;
  print_string "Num temp vars: "; print_int !temp_v_counter; print_newline ();
  let asm = ast |> codegen gen in (* tokenise -> parse -> generate assembly *)
  let ch = open_out "output.s" in
  Printf.fprintf ch "%s" asm (* write assembly to file *)