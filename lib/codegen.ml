(* Turn AST into assembly *)

open Lexer
open Parser
open Printf
(* open Helpers *)
let _STACK_SIZE = 1024

type generator = {
  variables: (string, int) Hashtbl.t;
  mutable instruction_count: int;
  mutable instructions: string;
  filepath: string;
  channel: out_channel
}

module type CodeGenerator = sig
  val new_generator : string -> generator
  val close_generator : generator -> unit

  val gen_plus_op : string -> string -> generator -> (string * int)
  val gen_mult_op : string -> string -> generator -> (string * int)
  val gen_print : string -> generator -> generator
  val gen_copy_ident : string -> string -> generator -> generator
end

let new_generator_ filename extension =
  let filepath = (Filename.chop_extension filename) ^ extension in
  {
    variables = Hashtbl.create 100;
    instructions = "";
    instruction_count = 0;
    filepath;
    channel = open_out filepath
  }

let emit str gen =
  gen.instruction_count <- gen.instruction_count + 1;
  gen.instructions <- gen.instructions ^ "  " ^ str ^ "\n";
  gen

let bottom_var g = Hashtbl.fold (fun _ v c -> if v >= c then (v+8) else c) g.variables 0
let empty_var g i = (bottom_var g)+(8*(i-1))

let is_alloc_var gen var_name = Hashtbl.mem gen.variables var_name
let alloc_var var_name (g: generator) = if Hashtbl.mem g.variables var_name then
                                          failwith "Var already exists!!!"
                                        else
                                          let available = empty_var g 1 in
                                          Logs.debug (fun m -> m "[Codegen] Allocating variable '%s' at offset %d" var_name available);
                                          Hashtbl.add g.variables var_name available; available

module JS_Backend : CodeGenerator = struct
  let new_generator filename = new_generator_ filename ".js"
  let close_generator g = close_out g.channel
  let gen_plus_op a b gen = 
    let name, off (* Don't need offset in JS *) = alloc_temp_var gen in
    let _ = gen
    |> emit ("let " ^ name ^ " = " ^ a ^ "+" ^ b)    
    in
    (name, off)

  let gen_mult_op a b gen = 
    let name, off (* Don't need offset in JS *) = alloc_temp_var gen in
    let _ = gen
    |> emit ("let " ^ name ^ " = " ^ a ^ "*" ^ b)    
    in
    (name, off)
  let gen_print var gen = emit ("console.log(" ^ var ^ ")") gen
  let generate_copy_ident target name gen = gen |> emit (target ^ " = " ^ name)
end

module X64_Backend : CodeGenerator = struct
  let new_generator filename = new_generator_ filename ".s"
  let close_generator g = close_out g.channel
  let gen_plus_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rcx, " ^ b)
    |> emit "add rax, rcx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_mult_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rdx, " ^ b)
    |> emit "mul rdx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_print var_name gen = 
    let offset = Hashtbl.find gen.variables var_name in
  emit ("
    mov edi, out      ; 64-bit ABI passing order starts w/ edi, esi, ... so format string goes into the first argument
    mov esi, [rsp+" ^ string_of_int offset ^ "]  ; arg1 goes into esi
    mov eax, 0        ; printf has varargs so eax counts num. of non-integer arguments being passed
    call printf
  ") gen
  let generate_copy_ident target name gen = 
    gen
    |> emit ("mov rax, " ^ var gen name)
    |> emit ("mov " ^ var gen target ^ ", rax")
end

let generate_begin =
"
; Generated by Paper-lang compiler
section .data
  out: db '%d', 10, 0

section .text
global _start       ; Provide program starting address to linker
"

let generate_startup =
"
extern printf
extern addTen

_start:
  ; Preallocate 1024 bytes on the stack to use for the whole program (for now)
  sub rsp, 1024

"

let generate_end =
"
  add rsp, 1024 ; Return stack pointer to start 
"

let generate_exit = "
  ; Load Linux exit syscall
  mov rdi, 0
  mov rax, 60
  syscall
"

type calling_convention = Microsoft_x64 | System_V


let temp_v_counter = ref 1
let alloc_temp_var g = 
  let var_name = ("__temp" ^ (string_of_int !temp_v_counter))  in
  if Hashtbl.mem g.variables var_name then
    failwith "Var already exists!!!"
  else let available = empty_var g 1 in
    temp_v_counter := !temp_v_counter + 1;
    Logs.debug (fun m -> m "[Codegen] Allocating temp variable '%s' at offset %d" var_name available);
    Hashtbl.add g.variables var_name available; (var_name, available)

  




(* let var g s = "[rsp+" ^ string_of_int (Hashtbl.find g.variables s) ^ "]" *)
let var _g s = s

let rec gen_from_expr gen expr : (generator * string) = match expr with
  | Grouping e -> gen_from_expr gen e.expr
  | Binary b -> begin
    match b.operator with
    | t when t.token_type = Plus -> begin
      match b.left_expr, b.right_expr with
      (* Num + Num *)
      | IntConst a,  IntConst b ->
        let (name, _) = gen_plus_op (string_of_int a) (string_of_int b) gen in
        (* print_hashtbl gen.variables; *)
        gen, name
      (* Num + Expr *)
      | IntConst a, e ->
        let (new_gen, temp_name) = gen_from_expr gen e in
        let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
        new_gen, name
      (* Expr + Num *)
      | e, IntConst a ->
        let (new_gen, temp_name) = gen_from_expr gen e in
        let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
        new_gen, name
      | le, re ->
        let (new_gen, left_temp_name) = gen_from_expr gen le in
        let new_gen, right_temp_name = gen_from_expr new_gen re in
        let name, _ = gen_plus_op left_temp_name right_temp_name new_gen in
        new_gen, name
      (* | _ -> failwith (Printf.sprintf "Cant add these types [%s] + [%s]" (string_of_expr b.left_expr) (string_of_expr b.right_expr)) *)
    end
    | t when t.token_type = Star -> begin
      match b.left_expr, b.right_expr with
      (* Num + Num *)
      | IntConst a, IntConst b ->
        let (name, _) = gen_mult_op (string_of_int a) (string_of_int b) gen in
        gen, name
      | IntConst a, e ->
        let (new_gen, temp_name) = gen_from_expr gen e in
        let (name, _offset) = gen_mult_op (string_of_int a) (var new_gen temp_name) new_gen in
        new_gen, name
      | e, IntConst a ->
        let (new_gen, temp_name) = gen_from_expr gen e in
        let (name, _offset) = gen_mult_op (string_of_int a) (var new_gen temp_name) new_gen in
        new_gen, name
      | le, re ->
        let (new_gen, left_temp_name) = gen_from_expr gen le in
        let new_gen, right_temp_name = gen_from_expr new_gen re in
        let name, _ = gen_mult_op left_temp_name right_temp_name new_gen in
        new_gen, name
      (* | _ -> failwith "Cant multiply these types" *)
    end
    | _ -> failwith "todo : implement this operator for binary expression"
  end
  | IntConst x -> gen, (string_of_int x)
  | _ -> failwith "todo: handle this expression in generator"




let gen_from_stmt gen (ast: statement) = match ast with
  | LetDecl e ->
        (* Check if var has already been allocated *)
        let _offset = if is_alloc_var gen e.identifier then
          Hashtbl.find gen.variables e.identifier
        else 
        (* Allocate the variable to keep track of it *)
          alloc_var e.identifier gen
        in
        (* Compute what we want to store in it *)
        let (new_gen, name) = gen_from_expr gen e.expr in
        (* print_hashtbl gen.variables; *)
        (* let _ = generate_copy_ident e.identifier name gen in  *)
        (* let _offset2 = Hashtbl.find new_gen.variables name in *)
        let new_gen = generate_copy_ident e.identifier name new_gen in
        new_gen
  | Print e -> begin
    match e with
    | Var v -> gen_print v gen
    | _ -> gen
  end
  | _ -> gen


let codegen gen (ast: statement list) : string = 
  let _stmt = List.nth ast 0 in
  let rec inner gen stmts = match stmts with
    | [] -> gen
    | s :: rest ->
      let next = gen_from_stmt gen s in
      inner next rest
  in
  let final = inner gen ast in
  (* let final = gen_add_ten "5" final in *)
  let final = gen_print "a" final in (* TODO: fix print statement parsing so I dont have to tack this on manually at the end *)
  (* let output = generate_begin ^ generate_startup ^  final.asm ^ generate_end ^ generate_exit in *)
  let output = final.instructions in
  output

type target = AMD64 | AARCH_64 | RISCV | JS | WASM (* Target platforms that I'd like to support *)

let compile ~target filepath (_ast: statement list) =
  let gen = match target with
    | AMD64 -> X64_Backend.new_generator filepath
    | AARCH_64 -> failwith "This backend is not implemented yet"
    | RISCV -> failwith "This backend is not implemented yet"
    | JS -> JS_Backend.new_generator filepath
    | WASM -> failwith "This backend is not implemented yet"
  in
  let ch = open_out "output.js" in
  Printf.fprintf ch "%s" gen.instructions 

let test_gen () = 
  let s = "let a = (10 + 10) * (10 * 5)\n" in
  let ast = s |> tokenise |> parse in
  print_endline "List: "; List.iter print_stmt ast;
  let gen = new_generator "output.js" in
  print_endline "Before:";
  let ast = s |> tokenise |> parse  in List.iter print_stmt ast; print_newline ();
  print_endline "After:";
  let ast = s |> tokenise |> parse |> Optimise.constant_fold in List.iter print_stmt ast; print_newline ();
  printf "Num temp vars: %d\n" !temp_v_counter;
  let asm = ast |> Optimise.constant_fold |> codegen gen in (* tokenise -> parse -> generate assembly *)
  printf "Instruction count: %d\n" gen.instruction_count;
  let ch = open_out gen.filepath in
  Printf.fprintf ch "%s" asm (* write assembly to file *)