(* Turn AST into assembly *)

open Lexer
open Parser
open Printf
(* open Helpers *)
let _MAX_STACK_SIZE = 1024
let temp_v_counter = ref 0

type generator = {
  variables: (string, int) Hashtbl.t;
  mutable instruction_count: int;
  mutable instructions: string;
  filepath: string;
  channel: out_channel
}

module type CodeGenerator = sig
  val new_generator : string -> generator
  val close_generator : generator -> unit
  val generate_begin : string
  val generate_end : string
  val generate_entrypoint : string
  val generate_exit : string
  val var : generator -> string -> string
  val gen_plus_op : string -> string -> generator -> (string * int)
  val gen_sub_op : string -> string -> generator -> (string * int)
  val gen_mult_op : string -> string -> generator -> (string * int)
  val gen_print : string -> generator -> generator
  val gen_copy_ident : string -> string -> generator -> generator
  val gen_assign : string -> string -> generator -> generator
  (*                     name   -> body     *)
  val gen_def_function : string -> token list -> string -> generator -> generator
end

let new_generator_ filename extension =
  let filepath = (Filename.chop_extension filename) ^ extension in
  {
    variables = Hashtbl.create 100;
    instructions = "";
    instruction_count = 0;
    filepath;
    channel = open_out filepath
  }

(* Target platform agnostic helpers *)
let emit str gen =
  gen.instruction_count <- gen.instruction_count + 1;
  gen.instructions <- gen.instructions ^ "  " ^ str ^ "\n";
  gen

let bottom_var g = Hashtbl.fold (fun _ v c -> if v >= c then (v+8) else c) g.variables 0
let empty_var g i = (bottom_var g)+(8*(i-1))

let is_alloc_var gen var_name = Hashtbl.mem gen.variables var_name
let alloc_var var_name (g: generator) = if Hashtbl.mem g.variables var_name then
                                          failwith "Var already exists!!!"
                                        else
                                          let available = empty_var g 1 in
                                          Logs.debug (fun m -> m "[Codegen] Allocating variable '%s' at offset %d" var_name available);
                                          Hashtbl.add g.variables var_name available; available

let alloc_temp_var g = 
  let var_name = ("__temp" ^ (string_of_int !temp_v_counter))  in
  if Hashtbl.mem g.variables var_name then
    failwith "Var already exists!!!"
  else let available = empty_var g 1 in
    temp_v_counter := !temp_v_counter + 1;
    Logs.debug (fun m -> m "[Codegen] Allocating temp variable '%s' at offset %d" var_name available);
    Hashtbl.add g.variables var_name available; (var_name, available)

module JS_CodeGen : CodeGenerator = struct
  let new_generator filename = new_generator_ filename ".js"
  let close_generator g = close_out g.channel
  let generate_begin = ""
  let generate_end = ""
  let generate_entrypoint = ""
  let generate_exit = ""
  let var _g s = s
  let gen_plus_op a b gen = 
    let name, off (* Don't need offset in JS *) = alloc_temp_var gen in
    let _ = gen
    |> emit ("const " ^ name ^ " = " ^ a ^ "+" ^ b)    
    in
    (name, off)
  let gen_sub_op a b gen = 
    let name, off (* Don't need offset in JS *) = alloc_temp_var gen in
    let _ = gen
    |> emit ("const " ^ name ^ " = " ^ a ^ "-" ^ b)    
    in
    (name, off)
  let gen_mult_op a b gen = 
    let name, off (* Don't need offset in JS *) = alloc_temp_var gen in
    let _ = gen
    |> emit ("let " ^ name ^ " = " ^ a ^ "*" ^ b)    
    in
    (name, off)
  let gen_print var gen = emit ("console.log(" ^ var ^ ")") gen
  let gen_copy_ident target name gen = gen |> emit ("const " ^ target ^ " = " ^ name)
  let gen_assign target str gen = gen |> emit ("const " ^ target ^ " = " ^ str)
  let gen_def_function name args body (gen: generator) =
    let arg_str = (List.nth args 0).lexeme in
    gen |> emit ("function " ^ name ^ "(" ^ arg_str  ^ ") {\n" ^ body ^ "\n}\n")
end

module X64_CodeGen : CodeGenerator = struct
  let new_generator filename = new_generator_ filename ".s"
  let close_generator g = close_out g.channel

  let generate_begin =
    "
; Generated by Paper-lang compiler
section .data
  out: db '%d', 10, 0

section .text
global _start       ; Provide program starting address to linker
    "
    
    let generate_entrypoint =
    "
extern printf
extern addTen

_start:
  ; Preallocate 1024 bytes on the stack to use for the whole program (for now)
  sub rsp, 1024
"
    
    let generate_end =
    "
  add rsp, 1024 ; Return stack pointer to start 
    "
    
    let generate_exit = "
  ; Load Linux exit syscall
  mov rdi, 0
  mov rax, 60
  syscall
    "
  let var g s = print_string "str:"; print_string s; Helpers.print_hashtbl g.variables; "[rsp+" ^ string_of_int (Hashtbl.find g.variables s) ^ "]"
  let gen_plus_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rcx, " ^ b)
    |> emit "add rax, rcx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_sub_op _a _b _gen = ("", 0)
  let gen_mult_op a b gen =
    let name, offset = alloc_temp_var gen in
    let _ = gen
    |> emit ("mov rax, " ^ a)
    |> emit ("mov rdx, " ^ b)
    |> emit "mul rdx ; output of addition is now in rax"
    |> emit ("mov [rsp+" ^ string_of_int offset ^ "], rax ; move onto stack")
    in
    (name, offset)
  let gen_print var_name gen =
    print_string "print"; print_string var_name; 
    let offset = Hashtbl.find gen.variables var_name in
  emit ("
  mov edi, out      ; 64-bit ABI passing order starts w/ edi, esi, ... so format string goes into the first argument
  mov esi, [rsp+" ^ string_of_int offset ^ "]  ; arg1 goes into esi
  mov eax, 0        ; printf has varargs so eax counts num. of non-integer arguments being passed
  call printf
  ") gen
  let gen_copy_ident target name gen = 
    print_string "HELLO"; print_string target; print_string name;
    gen
    |> emit ("mov rax, " ^ var gen name)
    |> emit ("mov " ^ var gen target ^ ", rax")
    let gen_assign target str gen = gen
    |> emit ("mov qword " ^ var gen target ^ ", " ^ str) (* only dealing with 64 bit data types for now *)

  let gen_def_function _ _ _ (g: generator) = g
end

type calling_convention = Microsoft_x64 | System_V

module Backend (CG : CodeGenerator) = struct
  include CG

  let rec gen_from_expr gen expr : (generator * string) = match expr with
    | Grouping e -> gen_from_expr gen e.expr
    | Binary b -> begin
      match b.operator with
      | t when t.token_type = Plus -> begin
        match b.left_expr, b.right_expr with
        (* Num + Num *)
        | IntConst a,  IntConst b ->
          let (name, _) = gen_plus_op (string_of_int a) (string_of_int b) gen in
          (* print_hashtbl gen.variables; *)
          gen, name
        | IntConst a, Var b ->
          let temp_name, _ = alloc_temp_var gen in
          let new_gen = gen_copy_ident temp_name (var gen b) gen in
          let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
          new_gen, name

        (* Num + Expr *)
        | IntConst a, e ->
          let (new_gen, temp_name) = gen_from_expr gen e in
          let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
          new_gen, name
        (* Expr + Num *)
        | e, IntConst a ->
          let (new_gen, temp_name) = gen_from_expr gen e in
          let (name, _offset) = gen_plus_op (string_of_int a) (var new_gen temp_name) new_gen in
          new_gen, name
        | le, re ->
          let (new_gen, left_temp_name) = gen_from_expr gen le in
          let new_gen, right_temp_name = gen_from_expr new_gen re in
          let name, _ = gen_plus_op left_temp_name right_temp_name new_gen in
          new_gen, name
        (* | _ -> failwith (Printf.sprintf "Cant add these types [%s] + [%s]" (string_of_expr b.left_expr) (string_of_expr b.right_expr)) *)
      end
      | t when t.token_type = Minus -> begin
        match b.left_expr, b.right_expr with
        (* Expr - Num *)
        | e, IntConst a ->
          let (new_gen, temp_name) = gen_from_expr gen e in
          let (name, _offset) = gen_sub_op (var new_gen temp_name) (string_of_int a) new_gen in
          new_gen, name
        | _ -> failwith ""
      end
      | t when t.token_type = Star -> begin
        match b.left_expr, b.right_expr with
        (* Num * Num *)
        | IntConst a, IntConst b ->
          let (name, _) = gen_mult_op (string_of_int a) (string_of_int b) gen in
          gen, name
        | IntConst a, e ->
          let (new_gen, temp_name) = gen_from_expr gen e in
          let (name, _offset) = gen_mult_op (string_of_int a) (var new_gen temp_name) new_gen in
          new_gen, name
        | e, IntConst a ->
          let (new_gen, temp_name) = gen_from_expr gen e in
          let (name, _offset) = gen_mult_op (string_of_int a) (var new_gen temp_name) new_gen in
          new_gen, name
        | le, re ->
          let (new_gen, left_temp_name) = gen_from_expr gen le in
          let new_gen, right_temp_name = gen_from_expr new_gen re in
          let name, _ = gen_mult_op left_temp_name right_temp_name new_gen in
          new_gen, name
      end
      | t when t.token_type = LessThan -> begin
        match b.left_expr, b.right_expr with
        | e, IntConst a ->
          print_endline "Here brah";
          let (new_gen, temp_name) = gen_from_expr gen e in
          let instr =  sprintf "%s < %s" (var new_gen temp_name) (string_of_int a) in
          let new_gen = emit instr new_gen in
          new_gen, instr
        | _ -> failwith "sdsdsdsd"
      end
      | _ -> print_string "HERE"; print_newline (); print_token b.operator; failwith "todo : implement this operator for binary expression"
    end
    | IntConst x -> gen, (string_of_int x)
    | Var s -> gen, s
    | Call c -> 
      
      print_endline "HERE";
      let ident = match c.callee with
      | Var s -> s
      | _ -> failwith "rip" in
      let args = List.map (fun t -> t.lexeme) c.arguments in
      (* let temp_name, _ = alloc_temp_var gen in *)
      let temp_name, _ = alloc_temp_var gen in
      let new_gen = gen_copy_ident temp_name (sprintf "%s(%s)" ident (List.nth args 0)) gen in
      new_gen, temp_name
      (* emit  gen, "" *)

    | e -> printf "%s \n" (string_of_expr e);
        failwith "todo: handle this expression in generator"
        (* gen, temp_name *)

  and gen_from_stmt gen (ast: statement) = match ast with
    | LetDecl e ->
          (* Check if var has already been allocated *)
          let _offset = if is_alloc_var gen e.identifier then
            Hashtbl.find gen.variables e.identifier
          else 
          (* Allocate the variable to keep track of it *)
            alloc_var e.identifier gen
          in begin match e.expr with
          | IntConst x -> 
              let (new_gen, name) = gen_from_expr gen e.expr in
              print_string "Name: "; print_string name;
              let new_gen = gen_assign e.identifier (string_of_int x) new_gen in
              new_gen
          | _ -> 
              (* Compute what we want to store in it *)
              let (new_gen, name) = gen_from_expr gen e.expr in
              print_string "Name: "; print_string name;
              let new_gen = gen_assign e.identifier name new_gen in
              new_gen
          end
    | Print e -> begin
      match e with
      | Var v -> gen_print v gen
      | _ -> gen
    end
    | Expression _ -> failwith "todo: implement Expression Codegen"
    | FunctionDecl f ->
      print_endline "Start function decl";
      let dummy_generator = new_generator "functiondecl.js" in
      let rec inner gen stmts = match stmts with
      | [] -> gen
      | s :: rest ->
        let next = gen_from_stmt gen s in
        inner next rest
      in
      let final = inner dummy_generator f.body in
      printf "Instructions for %s: \n %s\n\n" f.name final.instructions;
      let body_instructions = final.instructions in
      let new_gen = gen_def_function f.name f.arguments body_instructions gen in
      print_string "Current instructions: \n"; print_string new_gen.instructions; print_newline ();
      new_gen
    | IfElse ie -> 
      let dummy_generator = new_generator "functiondecl.js" in
      let _condition_gen, cond_str = gen_from_expr dummy_generator ie.condition in
      (* let condition_instr = condition_gen.instructions in *)
      let dummy_generator = new_generator "functiondecl.js" in
      let then_gen = gen_from_stmt dummy_generator ie.then_branch in
      let then_branch_instr = then_gen.instructions in
      let dummy_generator = new_generator "functiondecl.js" in
      let else_gen = gen_from_stmt dummy_generator ie.else_branch in
      let else_branch_instr = else_gen.instructions in
      let output = sprintf
      "if (%s) {\n %s } else {\n %s }\n" cond_str then_branch_instr else_branch_instr in
      emit output gen
    | Return r -> 
      let dummy_generator = new_generator "functiondecl.js" in
      let g, return_str = gen_from_expr dummy_generator r.value in
      emit (sprintf "%s\n return %s" g.instructions return_str) gen

  and codegen gen (ast: statement list) : string = 
    let _stmt = List.nth ast 0 in
    let rec inner gen stmts = match stmts with
      | [] -> gen
      | s :: rest ->
        let next = gen_from_stmt gen s in
        inner next rest
    in
    let final = inner gen ast in
    let output = generate_begin ^ generate_entrypoint ^  final.instructions ^ generate_end ^ generate_exit in
    output
end

type target = AMD64 | AARCH_64 | RISCV | JS | WASM (* Target platforms that I'd like to support *)

module X64_Backend = Backend (X64_CodeGen)
module JS_Backend = Backend (JS_CodeGen)

let compile ~target filepath (_ast: statement list) =
  let gen = match target with
    | AMD64 -> X64_Backend.new_generator filepath
    | AARCH_64 -> failwith "This backend is not implemented yet"
    | RISCV -> failwith "This backend is not implemented yet"
    | JS -> JS_Backend.new_generator filepath
    | WASM -> failwith "This backend is not implemented yet"
  in
  let ch = open_out "output.js" in
  Printf.fprintf ch "%s" gen.instructions 

let test_gen () = 
  let s = "let a = (10 + 10) * 20\n" in
  let ast = s |> tokenise |> parse in
  print_endline "List: "; List.iter print_stmt ast;
  let gen = X64_Backend.new_generator "output.s" in
  printf "Num temp vars: %d\n" !temp_v_counter;
  let asm = ast |> Optimise.constant_fold |> X64_Backend.codegen gen in
  printf "Instruction count: %d\n" gen.instruction_count;
  let ch = open_out gen.filepath in
  Printf.fprintf ch "%s" asm (* write assembly to file *)